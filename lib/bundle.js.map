{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E,6EAA6E;;AAE7E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,gDAAgD;AAChD,yFAAyF,wBAAwB;AACjH,+CAA+C;AAC/C;AACA,KAAK;;AAEL;AACA,gDAAgD,aAAa;AAC7D,+CAA+C;AAC/C;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC,kCAAkC,4BAA4B;AAC9D,gCAAgC,wBAAwB;AACxD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC,sBAAsB,gBAAgB;AACtC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,wCAAwC;AACxC;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,O;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;;AAEA,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,yD;AACA,oDAAoD;AACpD,sCAAsC,aAAa,sBAAsB,eAAe;AACxF;;AAEA;AACA,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","window.addEventListener('keydown', function (e) {\n  if ([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {\n    e.preventDefault();\n  }\n}, false);\n\nlet lastDownTarget;\n\ndocument.addEventListener('mousedown', function (e) {\n  lastDownTarget = e.target;\n}, false);\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const canvas = $j('#game-frame').nodes[0];\n  startButton = $j('#start-button');\n  pauseButton = $j('#pause-button');\n  gameOverButton = $j('#game-over');\n\n  const focusOnGame = [canvas, startButton.nodes[0], pauseButton.nodes[0], gameOverButton.nodes[0]];\n  document.addEventListener('keydown', function (e) {\n    if (focusOnGame.includes(lastDownTarget)) {\n      handleKeydown(e);\n    }\n  }, false);\n\n  const handleKeydown = (e) => {\n    if (e.key === 'ArrowDown') {\n      rotate = false;\n      if (dx < 0 || dy < 0) {\n        dx = -dx;\n        dy = -dy;\n      }\n    } else if (e.key === 'ArrowUp' && dx > 0 && !rotate) {\n      dx = -dx;\n      dy = -dy;\n    }\n  };\n\n  canvas.addEventListener('keydown', handleKeydown);\n  moreMenu = $j('#more-menu');\n  $j('#show-more').on('click', () => moreMenu.attr('style', 'display: block;'));\n  moreMenu.find('a').on('click', () => moreMenu.attr('style', 'display: none;'));\n\n  if (canvas.getContext) {\n    ctx = canvas.getContext('2d');\n\n    magnet = new Image();\n    magnet.src = './images/magnet.png';\n    magnet.addEventListener('load', startGame, false);\n    \n    bitcoin = new Image();\n    bitcoin.value = Math.round(Math.random() * 100) + 100;\n    bitcoin.slowdown = 3.5;\n    bitcoin.name = 'bitcoin';\n    bitcoin.src = './images/bitcoin.png';\n    \n    tron = new Image();\n    tron.slowdown = 2;\n    tron.name = 'tron';\n    tron.value = Math.round(Math.random() * 100) + 20;\n    tron.src = './images/tron.png';\n    \n    penny = new Image();\n    penny.value = 0.01\n    penny.slowdown = 1;\n    penny.name = 'penny';\n    penny.src = './images/penny.png';\n\n    startButton.on('click', () => {\n      $j('#panel').attr('style', 'display: block;');\n      $j('#pc').attr('style', 'display: block;');\n      if (startButton.html() === 'Start') time = 1800;\n      ctx.fillStyle = '#010014';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.fill();\n      pauseButton.attr('style', 'display: block;')\n      $j('canvas').attr('style', \"background: url('./images/moving_stars.gif') no-repeat; background-size: cover;\");\n      startButton.attr('style', 'display: none;');\n      gameInterval = setInterval(play, 17);\n    })\n    \n    pauseButton.on('click', () => {\n      startButton.attr('style', 'display: block; left: 173px;').html('Unpause');\n      pauseButton.attr('style', 'display: none;');\n      clearInterval(gameInterval);\n    });\n\n    $j('#game-over').find('b').on('click', () => startGame())\n    \n    function startGame() {\n      startButton.html('Start');\n      $j('#game-over').attr('style', 'display: none; position: absolute;')\n        .find('p').html('');\n      round = 1;\n      money = 0;\n      points = [];\n      rotate = true;\n      forward = true;\n      rotationDiff = 0;\n      angle = 1;\n      rotation = 130;\n      x = 0;\n      y = 0;\n      translateX = canvas.width / 2;\n      dy = 6;\n      dx = 6;\n      firstMove = true;\n      maxReach = 225;\n      collected = [];\n      names = [];\n      coins = defaultCoins.map( coin => new Coin(coin));\n      startButton.attr('style', 'display: block;');\n    }\n\n    class Coin {\n      constructor(image) {\n        this.image = image;\n        this.name = image.name;\n        this.x = Math.random() * 500 + 50;\n        this.y = Math.random() * 260 + 90;\n        this.value = image.value;\n        this.slowdown = image.slowdown;\n      }\n    }\n    defaultCoins = [penny, tron, bitcoin];\n    coinSet = [penny, tron, bitcoin];\n    \n    function play() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      drawmagnet();\n      $j('#round').html(`Round: ${round}`);\n      $j('#money').html(`Money: ${Math.round(money * 100)/100}`);\n      $j('#time').html(`Time: ${Math.round((time--)/60)}`);\n      if(time <= 0) {\n        gameOver();\n      } else {\n        drawCoins(coins);\n        advanceRound();\n      }\n    }\n    \n    function advanceRound() {\n      if(coins.length === 0 && rotate) {\n        round += 1;\n        time += 900;\n        flashMessage(`Round ${round}!`);\n        for(let i = 0; i <= round + 2; i++) {\n          if (coinSet[i]) {\n            coins.push(new Coin(coinSet[i]));\n          } else {\n            newCoin = defaultCoins[Math.round(Math.random() * 2)];\n            coins.push(new Coin(newCoin));\n          }\n        }\n      }\n    }\n    \n    function drawmagnet() {\n      if (rotate) {\n        drawRotatingMagnet();\n      } else {\n        drawMovingMagnet();\n      }\n    }\n\n    function flashMessage(message) {\n      flash = $j('.flash-message');\n      if (Array.isArray(message)) {\n        message.forEach( (mess, i) => {\n          flash.html(mess);\n          flash.attr('style', 'opacity: 1; top: -10px');\n          setTimeout(\n            () => flash.attr('style', 'opacity: 0; top: 0;'),\n            1000 + i * 500\n          );\n        })\n      } else {\n        flash.html(message);\n        flash.attr('style', 'opacity: 1; top: -10px');\n        setTimeout(\n          () => flash.attr('style', 'opacity: 0; top: 0;'),\n          1000\n        )\n      }\n    }\n    \n    function drawMovingMagnet() {\n      if (y <= 0 && dy < 0) {\n        rotate = true;\n        while(collected.length > 0) {\n          if (names.length > 1) {\n            setTimeout(() => \n            {\n              flashMessage(names.map(name => ('+' + name)));\n              names = [];\n            }, 300);\n          } else {\n            flashMessage('+' + names.pop());\n          }\n          money += collected.pop();\n        }\n        dx = 6;\n        dy = 6;\n        return;\n      }\n\n      const degrees = rotation - rotationDiff;\n      if (degrees <= 90 && degrees >= 0) {\n        maxReach = Math.abs(degrees - 45) + 210;\n      } else if (degrees > 90) {\n        maxReach = 250 - (degrees - 90) * 2;\n      } else {\n        maxReach = 250 + degrees * 2;\n      }\n      \n      drawString();\n      l = Math.sqrt(x * x + y * y) + magnet.height / 2 + 10;\n      x2 = (translateX + l * Math.cos(angle + 0.785398));\n      y2 = (50 + l * Math.sin(angle + 0.785398));\n      points = [];\n      for (let startRad = 0; startRad < 2 * Math.PI; startRad += Math.PI/10) {\n        let x3 = x2 + 33 * Math.cos(startRad);\n        let y3 = y2 + 33 * Math.sin(startRad);\n        points.push([x3, y3]);\n      }\n      points.forEach( coord => {\n        ctx.fillStyle = 'green';\n        ctx.fillRect(coord[0] + Math.random() * 5, coord[1] + Math.random() * 5, 3, 3);\n      });\n\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      if (x + dx > maxReach || y + dy > maxReach) {\n        dx = -dx;\n        dy = -dy;\n      } \n      ctx.translate(translateX, 50);\n      ctx.rotate(angle);\n      \n      x += dx\n      y += dy;\n\n      ctx.drawImage(magnet, x, y);\n      ctx.restore();\n    }\n\n    function drawRotatingMagnet() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0)\n      angle = (rotation - rotationDiff) * Math.PI / 180;\n      ctx.translate(translateX, y + 50)\n      ctx.rotate(angle);\n      ctx.drawImage(magnet, 0, 0);\n      ctx.restore();\n      if (forward) {\n        rotationDiff++;\n        if (rotationDiff === 175) {\n          forward = false;\n          rotationDiff--;\n        }\n      } else {\n        rotationDiff--;\n        if(rotationDiff < 0) {\n          forward = true;\n          rotationDiff++;\n        }\n      }\n    }\n\n\n    function drawString() {\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.translate(translateX, 50)\n      ctx.rotate(angle);\n      ctx.beginPath();\n      ctx.strokeStyle = 'white'\n      ctx.moveTo(0, 0);\n      ctx.lineTo(x, y);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    function drawCoins() {\n      for (let i = 0; i < coins.length; i++) {\n        const coin = coins[i];\n        \n        for(let j = 0; j < points.length; j++) {\n          const point = points[j];\n\n          if (point[0] > coin.x && point[0] < coin.x + 20 && point[1] > coin.y && point[1] < coin.y + 20) {\n            coins.splice(i, 1);\n            i--;\n            collected.push(coin.value);\n            names.push(coin.name);\n            if (dx > 0 && dy > 0) {\n              dx = -dx / coin.slowdown;\n              dy = -dy / coin.slowdown;\n            }\n            break;\n          }\n        }\n        ctx.drawImage(coin.image, coin.x, coin.y, 20, 20)\n      }\n    }\n\n    function gameOver() {\n      clearInterval(gameInterval);\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      pauseButton.attr('style', 'display: none;')\n      const roundsLasted = round > 1 ? round + ' rounds' : '1 round';\n      const moneyCollected = Math.round(money * 100)/100; \n      $j('#game-over').attr('style', 'display: flex;')\n        .find('p').html(`You lasted ${roundsLasted}<br> and collected $${moneyCollected}!`);\n    }\n    \n  }\n})\n"],"sourceRoot":""}